token COMENTARIO
token COMENTARIO_LINEA
token GLOBAL
token ID
token SEMI
token GLOBAL
	 declaracion global variable
	 declaracion unica
token ID
token COLON
token ARRAY
token LBRACKET
token NUM
token RBRACKET
token SEMI
token COMENTARIO_LINEA
token FUNCTION
	 declaracion global array
	 secuencia declaraciones
token ID
token LPAREN
token ID
token COLON
token ARRAY
token LBRACKET
token RBRACKET
token COMMA
token ID
token RPAREN
	 lista parametros
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token ID
token MINUS
	 identificador
token NUM
token STEP
	 numero entero
	 resta
token NUM
token ID
	 numero entero
token ASSIGN
token ID
token PLUS
	 identificador
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token SEMI
	 acceso array
	 suma
	 asignacion variable
	 sentencia unica
token IF
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token LT
	 acceso array
token NUM
token THEN
	 numero entero
	 operacion menor
token CONTINUE
token END
	 continue
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token ID
token GT
	 identificador
token NUM
token THEN
	 numero entero
	 operacion mayor
token BREAK
token END
	 break
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token SEMI
	 for con step
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
token COMENTARIO_LINEA
token BEGIN
	 declaracion funcion con parametros
	 secuencia declaraciones
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token COMENTARIO_LINEA
token WRITE
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token STRING
token SEMI
	 cadena texto
	 write expresion
	 secuencia sentencias sin punto y coma
token READ
token ID
token SEMI
	 read variable
	 secuencia sentencias
token COMENTARIO_LINEA
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token NUM
token STEP
	 numero entero
token NUM
token ID
	 numero entero
token LBRACKET
token ID
token RBRACKET
	 identificador
token ASSIGN
token ID
token TIMES
	 identificador
token NUM
token PLUS
	 numero entero
	 multiplicacion
token NUM
token END
	 numero entero
	 suma
	 asignacion array
	 sentencia unica
token SEMI
	 for con step
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token GE
	 identificador
token NUM
token AND
	 numero entero
	 operacion mayor igual
token ID
token LE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion menor igual
	 operacion AND
token WRITE
token STRING
token SEMI
	 cadena texto
	 write expresion
	 sentencia unica
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token MOD
	 identificador
token NUM
token EQ
	 numero entero
	 modulo
token NUM
token THEN
	 numero entero
	 operacion igual
token WRITE
token STRING
token ELSE
	 cadena texto
	 write expresion
	 sentencia unica
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 asignacion variable
	 secuencia sentencias
token WRITE
token STRING
token SEMI
	 cadena texto
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token ELSE
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token COMMA
	 identificador
token NUM
token RPAREN
	 numero entero
	 lista argumentos
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token STRING
token SEMI
	 cadena texto
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token LPAREN
token ID
token GT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion mayor
token OR
	 expresion parentesis
token LPAREN
token ID
token LT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion menor
token THEN
	 expresion parentesis
	 operacion OR
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token NOT
token LPAREN
token ID
token NE
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion diferente
token THEN
	 expresion parentesis
	 operacion NOT
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
Array arr ocupa 10 posiciones de memoria
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 18
Variable: arr -> Direccion: 1
Variable: suma_vector -> Direccion: 11
Variable: total -> Direccion: 15
Variable: size -> Direccion: 13
Variable: resultado -> Direccion: 17
Variable: v -> Direccion: 12
Variable: num -> Direccion: 16
Variable: x -> Direccion: 0
Variable: i -> Direccion: 14


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LD        6,0(0)        load mp with maxaddr
1:      ST        0,0(0)        clear location 0
* * Fin del prefacio estandar
* -> programa
* -> declaracion: x
* Declaracion de variable: x (global)
2:      LDC       0,0(0)        global: inicializar variable x a cero
3:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: arr
* Declaracion de array: arr tamaño definido
* -> constante
4:      LDC       0,10(0)       cargar constante: 10
* <- constante
5:      LDC       0,0(0)        array: inicializar elemento 0 a cero
6:      ST        0,1(5)        array: almacenar en posicion 1
7:      LDC       0,0(0)        array: inicializar elemento 1 a cero
8:      ST        0,2(5)        array: almacenar en posicion 2
9:      LDC       0,0(0)        array: inicializar elemento 2 a cero
10:     ST        0,3(5)        array: almacenar en posicion 3
11:     LDC       0,0(0)        array: inicializar elemento 3 a cero
12:     ST        0,4(5)        array: almacenar en posicion 4
13:     LDC       0,0(0)        array: inicializar elemento 4 a cero
14:     ST        0,5(5)        array: almacenar en posicion 5
15:     LDC       0,0(0)        array: inicializar elemento 5 a cero
16:     ST        0,6(5)        array: almacenar en posicion 6
17:     LDC       0,0(0)        array: inicializar elemento 6 a cero
18:     ST        0,7(5)        array: almacenar en posicion 7
19:     LDC       0,0(0)        array: inicializar elemento 7 a cero
20:     ST        0,8(5)        array: almacenar en posicion 8
21:     LDC       0,0(0)        array: inicializar elemento 8 a cero
22:     ST        0,9(5)        array: almacenar en posicion 9
23:     LDC       0,0(0)        array: inicializar elemento 9 a cero
24:     ST        0,10(5)       array: almacenar en posicion 10
* <- declaracion
* registrada funcion: suma_vector
* -> declaracion: i
* Declaracion de variable: i (local)
25:     LDC       0,0(0)        local: inicializar variable i a cero
26:     ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> declaracion: num
* Declaracion de variable: num (local)
27:     LDC       0,0(0)        local: inicializar variable num a cero
28:     ST        0,16(5)       local: almacenar en direccion 16
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (local)
29:     LDC       0,0(0)        local: inicializar variable resultado a cero
30:     ST        0,17(5)       local: almacenar en direccion 17
* <- declaracion
* -> escribir
* -> string
* String: "Ingrese un número: "
31:     LDC       0,73(0)       string: cargar caracter 'I'
32:     OUT       0,0,0         string: escribir caracter
33:     LDC       0,110(0)      string: cargar caracter 'n'
34:     OUT       0,0,0         string: escribir caracter
35:     LDC       0,103(0)      string: cargar caracter 'g'
36:     OUT       0,0,0         string: escribir caracter
37:     LDC       0,114(0)      string: cargar caracter 'r'
38:     OUT       0,0,0         string: escribir caracter
39:     LDC       0,101(0)      string: cargar caracter 'e'
40:     OUT       0,0,0         string: escribir caracter
41:     LDC       0,115(0)      string: cargar caracter 's'
42:     OUT       0,0,0         string: escribir caracter
43:     LDC       0,101(0)      string: cargar caracter 'e'
44:     OUT       0,0,0         string: escribir caracter
45:     LDC       0,32(0)       string: cargar caracter ' '
46:     OUT       0,0,0         string: escribir caracter
47:     LDC       0,117(0)      string: cargar caracter 'u'
48:     OUT       0,0,0         string: escribir caracter
49:     LDC       0,110(0)      string: cargar caracter 'n'
50:     OUT       0,0,0         string: escribir caracter
51:     LDC       0,32(0)       string: cargar caracter ' '
52:     OUT       0,0,0         string: escribir caracter
53:     LDC       0,110(0)      string: cargar caracter 'n'
54:     OUT       0,0,0         string: escribir caracter
55:     LDC       0,250(0)      string: cargar caracter 'ú'
56:     OUT       0,0,0         string: escribir caracter
57:     LDC       0,109(0)      string: cargar caracter 'm'
58:     OUT       0,0,0         string: escribir caracter
59:     LDC       0,101(0)      string: cargar caracter 'e'
60:     OUT       0,0,0         string: escribir caracter
61:     LDC       0,114(0)      string: cargar caracter 'r'
62:     OUT       0,0,0         string: escribir caracter
63:     LDC       0,111(0)      string: cargar caracter 'o'
64:     OUT       0,0,0         string: escribir caracter
65:     LDC       0,58(0)       string: cargar caracter ':'
66:     OUT       0,0,0         string: escribir caracter
67:     LDC       0,32(0)       string: cargar caracter ' '
68:     OUT       0,0,0         string: escribir caracter
* <- string
69:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> leer
70:     IN        0,0,0         leer: lee un valor entero 
71:     ST        0,16(5)       leer: almaceno el valor entero leido en el id num
* <- leer
* -> for
* -> constante
72:     LDC       0,0(0)        cargar constante: 0
* <- constante
73:     ST        0,14(5)       for: inicializar variable i
* for: inicio del bucle
74:     LD        0,14(5)       for: cargar variable de control
75:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
76:     LDC       0,9(0)        cargar constante: 9
* <- constante
77:     LD        1,0(6)        for: cargar variable de pila temp
78:     SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> Operacion: por
* -> identificador
80:     LD        0,14(5)       cargar id: val[i]
* <- identificador
81:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
82:     LDC       0,2(0)        cargar constante: 2
* <- constante
83:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
84:     MUL       0,1,0         op: *
* <- Operacion: por
85:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
86:     LDC       0,1(0)        cargar constante: 1
* <- constante
87:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
88:     ADD       0,1,0         op: +
* <- Operacion: mas
89:     ST        0,0(6)        asignacion array: guardar valor
* -> identificador
90:     LD        0,14(5)       cargar id: val[i]
* <- identificador
91:     LDC       1,1(0)        asignacion array: cargar direccion base
92:     ADD       0,0,1         asignacion array: calcular direccion
93:     LD        1,0(6)        asignacion array: recuperar valor
94:     ST        1,0(0)        asignacion array: almacenar en posicion calculada
* <- asignacion
* for: punto de continue
95:     LD        0,14(5)       for: cargar variable para incremento
96:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
97:     LDC       0,1(0)        cargar constante: 1
* <- constante
98:     LD        1,0(6)        for: cargar variable de pila temp
99:     ADD       0,1,0         for: incrementar variable
100:    ST        0,14(5)       for: guardar variable incrementada
101:    LDA       7,-28(7)      for: salto al inicio
* for: fin del bucle
79:     JGT       0,22(7)       for: saltar si variable > final
* <- for
* -> if
* -> Operacion: and
* -> Operacion: mayorigual
* -> identificador
102:    LD        0,16(5)       cargar id: val[num]
* <- identificador
103:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
104:    LDC       0,0(0)        cargar constante: 0
* <- constante
105:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
106:    SUB       0,1,0         op: >=
107:    JGE       0,2(7)        saltar si AC>=0
108:    LDC       0,0(0)        caso falso
109:    LDA       7,1(7)        saltar caso verdadero
110:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
111:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menorigual
* -> identificador
112:    LD        0,16(5)       cargar id: val[num]
* <- identificador
113:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
114:    LDC       0,10(0)       cargar constante: 10
* <- constante
115:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
116:    SUB       0,1,0         op: <=
117:    JLE       0,2(7)        saltar si AC<=0
118:    LDC       0,0(0)        caso falso
119:    LDA       7,1(7)        saltar caso verdadero
120:    LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
121:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
122:    JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
123:    JEQ       0,2(7)        and: si derecho es falso, resultado es falso
124:    LDC       0,1(0)        and: ambos verdaderos
125:    LDA       7,1(7)        and: saltar caso falso
126:    LDC       0,0(0)        and: resultado falso
* <- Operacion: and
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "El número está en rango"
128:    LDC       0,69(0)       string: cargar caracter 'E'
129:    OUT       0,0,0         string: escribir caracter
130:    LDC       0,108(0)      string: cargar caracter 'l'
131:    OUT       0,0,0         string: escribir caracter
132:    LDC       0,32(0)       string: cargar caracter ' '
133:    OUT       0,0,0         string: escribir caracter
134:    LDC       0,110(0)      string: cargar caracter 'n'
135:    OUT       0,0,0         string: escribir caracter
136:    LDC       0,250(0)      string: cargar caracter 'ú'
137:    OUT       0,0,0         string: escribir caracter
138:    LDC       0,109(0)      string: cargar caracter 'm'
139:    OUT       0,0,0         string: escribir caracter
140:    LDC       0,101(0)      string: cargar caracter 'e'
141:    OUT       0,0,0         string: escribir caracter
142:    LDC       0,114(0)      string: cargar caracter 'r'
143:    OUT       0,0,0         string: escribir caracter
144:    LDC       0,111(0)      string: cargar caracter 'o'
145:    OUT       0,0,0         string: escribir caracter
146:    LDC       0,32(0)       string: cargar caracter ' '
147:    OUT       0,0,0         string: escribir caracter
148:    LDC       0,101(0)      string: cargar caracter 'e'
149:    OUT       0,0,0         string: escribir caracter
150:    LDC       0,115(0)      string: cargar caracter 's'
151:    OUT       0,0,0         string: escribir caracter
152:    LDC       0,116(0)      string: cargar caracter 't'
153:    OUT       0,0,0         string: escribir caracter
154:    LDC       0,225(0)      string: cargar caracter 'á'
155:    OUT       0,0,0         string: escribir caracter
156:    LDC       0,32(0)       string: cargar caracter ' '
157:    OUT       0,0,0         string: escribir caracter
158:    LDC       0,101(0)      string: cargar caracter 'e'
159:    OUT       0,0,0         string: escribir caracter
160:    LDC       0,110(0)      string: cargar caracter 'n'
161:    OUT       0,0,0         string: escribir caracter
162:    LDC       0,32(0)       string: cargar caracter ' '
163:    OUT       0,0,0         string: escribir caracter
164:    LDC       0,114(0)      string: cargar caracter 'r'
165:    OUT       0,0,0         string: escribir caracter
166:    LDC       0,97(0)       string: cargar caracter 'a'
167:    OUT       0,0,0         string: escribir caracter
168:    LDC       0,110(0)      string: cargar caracter 'n'
169:    OUT       0,0,0         string: escribir caracter
170:    LDC       0,103(0)      string: cargar caracter 'g'
171:    OUT       0,0,0         string: escribir caracter
172:    LDC       0,111(0)      string: cargar caracter 'o'
173:    OUT       0,0,0         string: escribir caracter
* <- string
174:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
175:    LD        0,16(5)       cargar id: val[num]
* <- identificador
176:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: igual
* -> Operacion: modulo
* -> identificador
177:    LD        0,16(5)       cargar id: val[num]
* <- identificador
178:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
179:    LDC       0,2(0)        cargar constante: 2
* <- constante
180:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
181:    ST        0,0(6)        mod: guardar b
182:    ST        1,-1(6)       mod: guardar a
183:    DIV       0,1,0         mod: a/b
184:    LD        1,-1(6)       mod: recuperar a
185:    LD        2,0(6)        mod: recuperar b en r2
186:    MUL       0,0,2         mod: (a/b)*b
187:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
188:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
189:    LDC       0,0(0)        cargar constante: 0
* <- constante
190:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
191:    SUB       0,1,0         op: ==
192:    JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
193:    LDC       0,0(0)        caso de falso (AC=0)
194:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
195:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "El número es par"
197:    LDC       0,69(0)       string: cargar caracter 'E'
198:    OUT       0,0,0         string: escribir caracter
199:    LDC       0,108(0)      string: cargar caracter 'l'
200:    OUT       0,0,0         string: escribir caracter
201:    LDC       0,32(0)       string: cargar caracter ' '
202:    OUT       0,0,0         string: escribir caracter
203:    LDC       0,110(0)      string: cargar caracter 'n'
204:    OUT       0,0,0         string: escribir caracter
205:    LDC       0,250(0)      string: cargar caracter 'ú'
206:    OUT       0,0,0         string: escribir caracter
207:    LDC       0,109(0)      string: cargar caracter 'm'
208:    OUT       0,0,0         string: escribir caracter
209:    LDC       0,101(0)      string: cargar caracter 'e'
210:    OUT       0,0,0         string: escribir caracter
211:    LDC       0,114(0)      string: cargar caracter 'r'
212:    OUT       0,0,0         string: escribir caracter
213:    LDC       0,111(0)      string: cargar caracter 'o'
214:    OUT       0,0,0         string: escribir caracter
215:    LDC       0,32(0)       string: cargar caracter ' '
216:    OUT       0,0,0         string: escribir caracter
217:    LDC       0,101(0)      string: cargar caracter 'e'
218:    OUT       0,0,0         string: escribir caracter
219:    LDC       0,115(0)      string: cargar caracter 's'
220:    OUT       0,0,0         string: escribir caracter
221:    LDC       0,32(0)       string: cargar caracter ' '
222:    OUT       0,0,0         string: escribir caracter
223:    LDC       0,112(0)      string: cargar caracter 'p'
224:    OUT       0,0,0         string: escribir caracter
225:    LDC       0,97(0)       string: cargar caracter 'a'
226:    OUT       0,0,0         string: escribir caracter
227:    LDC       0,114(0)      string: cargar caracter 'r'
228:    OUT       0,0,0         string: escribir caracter
* <- string
229:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
196:    JEQ       0,34(7)       if: jmp hacia else
* -> escribir
* -> string
* String: "El número es impar"
231:    LDC       0,69(0)       string: cargar caracter 'E'
232:    OUT       0,0,0         string: escribir caracter
233:    LDC       0,108(0)      string: cargar caracter 'l'
234:    OUT       0,0,0         string: escribir caracter
235:    LDC       0,32(0)       string: cargar caracter ' '
236:    OUT       0,0,0         string: escribir caracter
237:    LDC       0,110(0)      string: cargar caracter 'n'
238:    OUT       0,0,0         string: escribir caracter
239:    LDC       0,250(0)      string: cargar caracter 'ú'
240:    OUT       0,0,0         string: escribir caracter
241:    LDC       0,109(0)      string: cargar caracter 'm'
242:    OUT       0,0,0         string: escribir caracter
243:    LDC       0,101(0)      string: cargar caracter 'e'
244:    OUT       0,0,0         string: escribir caracter
245:    LDC       0,114(0)      string: cargar caracter 'r'
246:    OUT       0,0,0         string: escribir caracter
247:    LDC       0,111(0)      string: cargar caracter 'o'
248:    OUT       0,0,0         string: escribir caracter
249:    LDC       0,32(0)       string: cargar caracter ' '
250:    OUT       0,0,0         string: escribir caracter
251:    LDC       0,101(0)      string: cargar caracter 'e'
252:    OUT       0,0,0         string: escribir caracter
253:    LDC       0,115(0)      string: cargar caracter 's'
254:    OUT       0,0,0         string: escribir caracter
255:    LDC       0,32(0)       string: cargar caracter ' '
256:    OUT       0,0,0         string: escribir caracter
257:    LDC       0,105(0)      string: cargar caracter 'i'
258:    OUT       0,0,0         string: escribir caracter
259:    LDC       0,109(0)      string: cargar caracter 'm'
260:    OUT       0,0,0         string: escribir caracter
261:    LDC       0,112(0)      string: cargar caracter 'p'
262:    OUT       0,0,0         string: escribir caracter
263:    LDC       0,97(0)       string: cargar caracter 'a'
264:    OUT       0,0,0         string: escribir caracter
265:    LDC       0,114(0)      string: cargar caracter 'r'
266:    OUT       0,0,0         string: escribir caracter
* <- string
267:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
230:    LDA       7,37(7)       if: jmp hacia el final
* <- if
* -> asignacion
* -> Operacion: potencia
* -> identificador
268:    LD        0,16(5)       cargar id: val[num]
* <- identificador
269:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
270:    LDC       0,2(0)        cargar constante: 2
* <- constante
271:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
* potencia: implementación simplificada
272:    MUL       0,1,0         potencia: multiplicación simple
* <- Operacion: potencia
273:    ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> escribir
* -> string
* String: "El cuadrado es: "
274:    LDC       0,69(0)       string: cargar caracter 'E'
275:    OUT       0,0,0         string: escribir caracter
276:    LDC       0,108(0)      string: cargar caracter 'l'
277:    OUT       0,0,0         string: escribir caracter
278:    LDC       0,32(0)       string: cargar caracter ' '
279:    OUT       0,0,0         string: escribir caracter
280:    LDC       0,99(0)       string: cargar caracter 'c'
281:    OUT       0,0,0         string: escribir caracter
282:    LDC       0,117(0)      string: cargar caracter 'u'
283:    OUT       0,0,0         string: escribir caracter
284:    LDC       0,97(0)       string: cargar caracter 'a'
285:    OUT       0,0,0         string: escribir caracter
286:    LDC       0,100(0)      string: cargar caracter 'd'
287:    OUT       0,0,0         string: escribir caracter
288:    LDC       0,114(0)      string: cargar caracter 'r'
289:    OUT       0,0,0         string: escribir caracter
290:    LDC       0,97(0)       string: cargar caracter 'a'
291:    OUT       0,0,0         string: escribir caracter
292:    LDC       0,100(0)      string: cargar caracter 'd'
293:    OUT       0,0,0         string: escribir caracter
294:    LDC       0,111(0)      string: cargar caracter 'o'
295:    OUT       0,0,0         string: escribir caracter
296:    LDC       0,32(0)       string: cargar caracter ' '
297:    OUT       0,0,0         string: escribir caracter
298:    LDC       0,101(0)      string: cargar caracter 'e'
299:    OUT       0,0,0         string: escribir caracter
300:    LDC       0,115(0)      string: cargar caracter 's'
301:    OUT       0,0,0         string: escribir caracter
302:    LDC       0,58(0)       string: cargar caracter ':'
303:    OUT       0,0,0         string: escribir caracter
304:    LDC       0,32(0)       string: cargar caracter ' '
305:    OUT       0,0,0         string: escribir caracter
* <- string
306:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
307:    LD        0,0(5)        cargar id: val[x]
* <- identificador
308:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
127:    JEQ       0,182(7)      if: jmp hacia else
* -> escribir
* -> string
* String: "Número fuera de rango"
310:    LDC       0,78(0)       string: cargar caracter 'N'
311:    OUT       0,0,0         string: escribir caracter
312:    LDC       0,250(0)      string: cargar caracter 'ú'
313:    OUT       0,0,0         string: escribir caracter
314:    LDC       0,109(0)      string: cargar caracter 'm'
315:    OUT       0,0,0         string: escribir caracter
316:    LDC       0,101(0)      string: cargar caracter 'e'
317:    OUT       0,0,0         string: escribir caracter
318:    LDC       0,114(0)      string: cargar caracter 'r'
319:    OUT       0,0,0         string: escribir caracter
320:    LDC       0,111(0)      string: cargar caracter 'o'
321:    OUT       0,0,0         string: escribir caracter
322:    LDC       0,32(0)       string: cargar caracter ' '
323:    OUT       0,0,0         string: escribir caracter
324:    LDC       0,102(0)      string: cargar caracter 'f'
325:    OUT       0,0,0         string: escribir caracter
326:    LDC       0,117(0)      string: cargar caracter 'u'
327:    OUT       0,0,0         string: escribir caracter
328:    LDC       0,101(0)      string: cargar caracter 'e'
329:    OUT       0,0,0         string: escribir caracter
330:    LDC       0,114(0)      string: cargar caracter 'r'
331:    OUT       0,0,0         string: escribir caracter
332:    LDC       0,97(0)       string: cargar caracter 'a'
333:    OUT       0,0,0         string: escribir caracter
334:    LDC       0,32(0)       string: cargar caracter ' '
335:    OUT       0,0,0         string: escribir caracter
336:    LDC       0,100(0)      string: cargar caracter 'd'
337:    OUT       0,0,0         string: escribir caracter
338:    LDC       0,101(0)      string: cargar caracter 'e'
339:    OUT       0,0,0         string: escribir caracter
340:    LDC       0,32(0)       string: cargar caracter ' '
341:    OUT       0,0,0         string: escribir caracter
342:    LDC       0,114(0)      string: cargar caracter 'r'
343:    OUT       0,0,0         string: escribir caracter
344:    LDC       0,97(0)       string: cargar caracter 'a'
345:    OUT       0,0,0         string: escribir caracter
346:    LDC       0,110(0)      string: cargar caracter 'n'
347:    OUT       0,0,0         string: escribir caracter
348:    LDC       0,103(0)      string: cargar caracter 'g'
349:    OUT       0,0,0         string: escribir caracter
350:    LDC       0,111(0)      string: cargar caracter 'o'
351:    OUT       0,0,0         string: escribir caracter
* <- string
352:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
309:    LDA       7,43(7)       if: jmp hacia el final
* <- if
* -> asignacion
* -> llamada funcion: suma_vector
353:    ST        7,0(6)        call: guardar direccion de retorno
* Procesando argumentos de la llamada
* -> identificador
354:    LD        0,1(5)        cargar id: val[arr]
* <- identificador
* -> constante
355:    LDC       0,10(0)       cargar constante: 10
* <- constante
356:    ST        0,-1(6)       call: guardar argumento
* -> constante
357:    LDC       0,10(0)       cargar constante: 10
* <- constante
358:    ST        0,-2(6)       call: guardar argumento
* === INICIO FUNCION suma_vector ===
* -> declaracion: i
* Declaracion de variable: i (local)
359:    LDC       0,0(0)        local: inicializar variable i a cero
360:    ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> declaracion: total
* Declaracion de variable: total (local)
361:    LDC       0,0(0)        local: inicializar variable total a cero
362:    ST        0,15(5)       local: almacenar en direccion 15
* <- declaracion
* -> asignacion
* -> constante
363:    LDC       0,0(0)        cargar constante: 0
* <- constante
364:    ST        0,15(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> for
* -> constante
365:    LDC       0,0(0)        cargar constante: 0
* <- constante
366:    ST        0,14(5)       for: inicializar variable i
* for: inicio del bucle
367:    LD        0,14(5)       for: cargar variable de control
368:    ST        0,-3(6)       for: guardar variable en pila temp
* -> Operacion: menos
* -> identificador
369:    LD        0,13(5)       cargar id: val[size]
* <- identificador
370:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
371:    LDC       0,1(0)        cargar constante: 1
* <- constante
372:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
373:    SUB       0,1,0         op: -
* <- Operacion: menos
374:    LD        1,-3(6)       for: cargar variable de pila temp
375:    SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> identificador
377:    LD        0,15(5)       cargar id: val[total]
* <- identificador
378:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> identificador
379:    LD        0,14(5)       cargar id: val[i]
* <- identificador
380:    LDC       1,12(0)       identificador array: cargar direccion base
381:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
382:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
383:    ADD       0,1,0         op: +
* <- Operacion: mas
384:    ST        0,15(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> if
* -> Operacion: menor
* -> identificador
* -> identificador
385:    LD        0,14(5)       cargar id: val[i]
* <- identificador
386:    LDC       1,12(0)       identificador array: cargar direccion base
387:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
388:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
389:    LDC       0,0(0)        cargar constante: 0
* <- constante
390:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
391:    SUB       0,1,0         op: <
392:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
393:    LDC       0,0(0)        caso de falso (AC=0)
394:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
395:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
* If: el salto hacia el else debe estar aqui
* -> continue
* continue: salto al incremento del bucle
* <- continue
* If: el salto hacia el final debe estar aqui
396:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: mayor
* -> identificador
398:    LD        0,15(5)       cargar id: val[total]
* <- identificador
399:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
400:    LDC       0,1000(0)      cargar constante: 1000
* <- constante
401:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
402:    SUB       0,1,0         op: >
403:    JGT       0,2(7)        saltar si AC>0
404:    LDC       0,0(0)        caso falso
405:    LDA       7,1(7)        saltar caso verdadero
406:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
* If: el salto hacia el else debe estar aqui
* -> break
* break: salto al final del bucle
* <- break
* If: el salto hacia el final debe estar aqui
407:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* for: punto de continue
409:    LD        0,14(5)       for: cargar variable para incremento
410:    ST        0,-3(6)       for: guardar variable en pila temp
* -> constante
411:    LDC       0,1(0)        cargar constante: 1
* <- constante
412:    LD        1,-3(6)       for: cargar variable de pila temp
413:    ADD       0,1,0         for: incrementar variable
414:    ST        0,14(5)       for: guardar variable incrementada
415:    LDA       7,-49(7)      for: salto al inicio
* for: fin del bucle
376:    JGT       0,39(7)       for: saltar si variable > final
* <- for
* -> return
* -> identificador
416:    LD        0,15(5)       cargar id: val[total]
* <- identificador
417:    LD        1,-2(6)       return: recuperar direccion de retorno
418:    LD        7,0(1)        return: salto a direccion de retorno
* <- return
* Return implicito de funcion
419:    LD        1,-1(6)       funcion: recuperar direccion de retorno
420:    LD        7,0(1)        funcion: retorno
* === FIN FUNCION suma_vector ===
359:    LDA       7,-1(7)       call: salto a funcion suma_vector
* <- llamada funcion
421:    ST        0,17(5)       asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> string
* String: "La suma del vector es: "
422:    LDC       0,76(0)       string: cargar caracter 'L'
423:    OUT       0,0,0         string: escribir caracter
424:    LDC       0,97(0)       string: cargar caracter 'a'
425:    OUT       0,0,0         string: escribir caracter
426:    LDC       0,32(0)       string: cargar caracter ' '
427:    OUT       0,0,0         string: escribir caracter
428:    LDC       0,115(0)      string: cargar caracter 's'
429:    OUT       0,0,0         string: escribir caracter
430:    LDC       0,117(0)      string: cargar caracter 'u'
431:    OUT       0,0,0         string: escribir caracter
432:    LDC       0,109(0)      string: cargar caracter 'm'
433:    OUT       0,0,0         string: escribir caracter
434:    LDC       0,97(0)       string: cargar caracter 'a'
435:    OUT       0,0,0         string: escribir caracter
436:    LDC       0,32(0)       string: cargar caracter ' '
437:    OUT       0,0,0         string: escribir caracter
438:    LDC       0,100(0)      string: cargar caracter 'd'
439:    OUT       0,0,0         string: escribir caracter
440:    LDC       0,101(0)      string: cargar caracter 'e'
441:    OUT       0,0,0         string: escribir caracter
442:    LDC       0,108(0)      string: cargar caracter 'l'
443:    OUT       0,0,0         string: escribir caracter
444:    LDC       0,32(0)       string: cargar caracter ' '
445:    OUT       0,0,0         string: escribir caracter
446:    LDC       0,118(0)      string: cargar caracter 'v'
447:    OUT       0,0,0         string: escribir caracter
448:    LDC       0,101(0)      string: cargar caracter 'e'
449:    OUT       0,0,0         string: escribir caracter
450:    LDC       0,99(0)       string: cargar caracter 'c'
451:    OUT       0,0,0         string: escribir caracter
452:    LDC       0,116(0)      string: cargar caracter 't'
453:    OUT       0,0,0         string: escribir caracter
454:    LDC       0,111(0)      string: cargar caracter 'o'
455:    OUT       0,0,0         string: escribir caracter
456:    LDC       0,114(0)      string: cargar caracter 'r'
457:    OUT       0,0,0         string: escribir caracter
458:    LDC       0,32(0)       string: cargar caracter ' '
459:    OUT       0,0,0         string: escribir caracter
460:    LDC       0,101(0)      string: cargar caracter 'e'
461:    OUT       0,0,0         string: escribir caracter
462:    LDC       0,115(0)      string: cargar caracter 's'
463:    OUT       0,0,0         string: escribir caracter
464:    LDC       0,58(0)       string: cargar caracter ':'
465:    OUT       0,0,0         string: escribir caracter
466:    LDC       0,32(0)       string: cargar caracter ' '
467:    OUT       0,0,0         string: escribir caracter
* <- string
468:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
469:    LD        0,17(5)       cargar id: val[resultado]
* <- identificador
470:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: or
* -> Operacion: mayor
* -> identificador
471:    LD        0,16(5)       cargar id: val[num]
* <- identificador
472:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
473:    LDC       0,5(0)        cargar constante: 5
* <- constante
474:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
475:    SUB       0,1,0         op: >
476:    JGT       0,2(7)        saltar si AC>0
477:    LDC       0,0(0)        caso falso
478:    LDA       7,1(7)        saltar caso verdadero
479:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
480:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menor
* -> identificador
481:    LD        0,16(5)       cargar id: val[num]
* <- identificador
482:    ST        0,-2(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
483:    LDC       0,0(0)        cargar constante: 0
* <- constante
484:    LD        1,-2(6)       op: pop o cargo de la pila el valor izquierdo en AC1
485:    SUB       0,1,0         op: <
486:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
487:    LDC       0,0(0)        caso de falso (AC=0)
488:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
489:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
490:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
491:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
492:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
493:    LDC       0,0(0)        or: ambos falsos
494:    LDA       7,1(7)        or: saltar caso verdadero
495:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "Condición compleja verdadera"
497:    LDC       0,67(0)       string: cargar caracter 'C'
498:    OUT       0,0,0         string: escribir caracter
499:    LDC       0,111(0)      string: cargar caracter 'o'
500:    OUT       0,0,0         string: escribir caracter
501:    LDC       0,110(0)      string: cargar caracter 'n'
502:    OUT       0,0,0         string: escribir caracter
503:    LDC       0,100(0)      string: cargar caracter 'd'
504:    OUT       0,0,0         string: escribir caracter
505:    LDC       0,105(0)      string: cargar caracter 'i'
506:    OUT       0,0,0         string: escribir caracter
507:    LDC       0,99(0)       string: cargar caracter 'c'
508:    OUT       0,0,0         string: escribir caracter
509:    LDC       0,105(0)      string: cargar caracter 'i'
510:    OUT       0,0,0         string: escribir caracter
511:    LDC       0,243(0)      string: cargar caracter 'ó'
512:    OUT       0,0,0         string: escribir caracter
513:    LDC       0,110(0)      string: cargar caracter 'n'
514:    OUT       0,0,0         string: escribir caracter
515:    LDC       0,32(0)       string: cargar caracter ' '
516:    OUT       0,0,0         string: escribir caracter
517:    LDC       0,99(0)       string: cargar caracter 'c'
518:    OUT       0,0,0         string: escribir caracter
519:    LDC       0,111(0)      string: cargar caracter 'o'
520:    OUT       0,0,0         string: escribir caracter
521:    LDC       0,109(0)      string: cargar caracter 'm'
522:    OUT       0,0,0         string: escribir caracter
523:    LDC       0,112(0)      string: cargar caracter 'p'
524:    OUT       0,0,0         string: escribir caracter
525:    LDC       0,108(0)      string: cargar caracter 'l'
526:    OUT       0,0,0         string: escribir caracter
527:    LDC       0,101(0)      string: cargar caracter 'e'
528:    OUT       0,0,0         string: escribir caracter
529:    LDC       0,106(0)      string: cargar caracter 'j'
530:    OUT       0,0,0         string: escribir caracter
531:    LDC       0,97(0)       string: cargar caracter 'a'
532:    OUT       0,0,0         string: escribir caracter
533:    LDC       0,32(0)       string: cargar caracter ' '
534:    OUT       0,0,0         string: escribir caracter
535:    LDC       0,118(0)      string: cargar caracter 'v'
536:    OUT       0,0,0         string: escribir caracter
537:    LDC       0,101(0)      string: cargar caracter 'e'
538:    OUT       0,0,0         string: escribir caracter
539:    LDC       0,114(0)      string: cargar caracter 'r'
540:    OUT       0,0,0         string: escribir caracter
541:    LDC       0,100(0)      string: cargar caracter 'd'
542:    OUT       0,0,0         string: escribir caracter
543:    LDC       0,97(0)       string: cargar caracter 'a'
544:    OUT       0,0,0         string: escribir caracter
545:    LDC       0,100(0)      string: cargar caracter 'd'
546:    OUT       0,0,0         string: escribir caracter
547:    LDC       0,101(0)      string: cargar caracter 'e'
548:    OUT       0,0,0         string: escribir caracter
549:    LDC       0,114(0)      string: cargar caracter 'r'
550:    OUT       0,0,0         string: escribir caracter
551:    LDC       0,97(0)       string: cargar caracter 'a'
552:    OUT       0,0,0         string: escribir caracter
* <- string
553:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
496:    JEQ       0,58(7)       if: jmp hacia else
* <- if
* -> if
* -> Operacion: not
* -> Operacion: diferente
* -> identificador
555:    LD        0,16(5)       cargar id: val[num]
* <- identificador
556:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
557:    LDC       0,5(0)        cargar constante: 5
* <- constante
558:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
559:    SUB       0,1,0         op: !=
560:    JNE       0,2(7)        saltar si AC!=0
561:    LDC       0,0(0)        caso falso
562:    LDA       7,1(7)        saltar caso verdadero
563:    LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
564:    JEQ       0,2(7)        not: saltar si es cero (falso)
565:    LDC       0,0(0)        not: resultado falso
566:    LDA       7,1(7)        not: saltar carga de verdadero
567:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "El número es 5"
569:    LDC       0,69(0)       string: cargar caracter 'E'
570:    OUT       0,0,0         string: escribir caracter
571:    LDC       0,108(0)      string: cargar caracter 'l'
572:    OUT       0,0,0         string: escribir caracter
573:    LDC       0,32(0)       string: cargar caracter ' '
574:    OUT       0,0,0         string: escribir caracter
575:    LDC       0,110(0)      string: cargar caracter 'n'
576:    OUT       0,0,0         string: escribir caracter
577:    LDC       0,250(0)      string: cargar caracter 'ú'
578:    OUT       0,0,0         string: escribir caracter
579:    LDC       0,109(0)      string: cargar caracter 'm'
580:    OUT       0,0,0         string: escribir caracter
581:    LDC       0,101(0)      string: cargar caracter 'e'
582:    OUT       0,0,0         string: escribir caracter
583:    LDC       0,114(0)      string: cargar caracter 'r'
584:    OUT       0,0,0         string: escribir caracter
585:    LDC       0,111(0)      string: cargar caracter 'o'
586:    OUT       0,0,0         string: escribir caracter
587:    LDC       0,32(0)       string: cargar caracter ' '
588:    OUT       0,0,0         string: escribir caracter
589:    LDC       0,101(0)      string: cargar caracter 'e'
590:    OUT       0,0,0         string: escribir caracter
591:    LDC       0,115(0)      string: cargar caracter 's'
592:    OUT       0,0,0         string: escribir caracter
593:    LDC       0,32(0)       string: cargar caracter ' '
594:    OUT       0,0,0         string: escribir caracter
595:    LDC       0,53(0)       string: cargar caracter '5'
596:    OUT       0,0,0         string: escribir caracter
* <- string
597:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
568:    JEQ       0,30(7)       if: jmp hacia else
* <- if
* <- programa
* Fin de la ejecucion.
599:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------
