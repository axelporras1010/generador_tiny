token COMENTARIO
token COMENTARIO_LINEA
token GLOBAL
token ID
token SEMI
token GLOBAL
	 declaracion global variable
	 declaracion unica
token ID
token COLON
token ARRAY
token LBRACKET
token NUM
token RBRACKET
token SEMI
token COMENTARIO_LINEA
token FUNCTION
	 declaracion global array
	 secuencia declaraciones
token ID
token LPAREN
token ID
token COLON
token ARRAY
token LBRACKET
token RBRACKET
token COMMA
token ID
token RPAREN
	 lista parametros
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token ID
token MINUS
	 identificador
token NUM
token STEP
	 numero entero
	 resta
token NUM
token ID
	 numero entero
token ASSIGN
token ID
token PLUS
	 identificador
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token SEMI
	 acceso array
	 suma
	 asignacion variable
	 sentencia unica
token IF
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token LT
	 acceso array
token NUM
token THEN
	 numero entero
	 operacion menor
token CONTINUE
token END
	 continue
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token ID
token GT
	 identificador
token NUM
token THEN
	 numero entero
	 operacion mayor
token BREAK
token END
	 break
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token SEMI
	 for con step
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
token COMENTARIO_LINEA
token BEGIN
	 declaracion funcion con parametros
	 secuencia declaraciones
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token COMENTARIO_LINEA
token WRITE
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token STRING
token SEMI
	 cadena texto
	 write expresion
	 secuencia sentencias sin punto y coma
token READ
token ID
token SEMI
	 read variable
	 secuencia sentencias
token COMENTARIO_LINEA
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token NUM
token STEP
	 numero entero
token NUM
token ID
	 numero entero
token LBRACKET
token ID
token RBRACKET
	 identificador
token ASSIGN
token ID
token TIMES
	 identificador
token NUM
token PLUS
	 numero entero
	 multiplicacion
token NUM
token END
	 numero entero
	 suma
	 asignacion array
	 sentencia unica
token SEMI
	 for con step
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token GE
	 identificador
token NUM
token AND
	 numero entero
	 operacion mayor igual
token ID
token LE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion menor igual
	 operacion AND
token WRITE
token STRING
token SEMI
	 cadena texto
	 write expresion
	 sentencia unica
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token MOD
	 identificador
token NUM
token EQ
	 numero entero
	 modulo
token NUM
token THEN
	 numero entero
	 operacion igual
token WRITE
token STRING
token ELSE
	 cadena texto
	 write expresion
	 sentencia unica
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 asignacion variable
	 secuencia sentencias
token WRITE
token STRING
token SEMI
	 cadena texto
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token ELSE
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token COMMA
	 identificador
token NUM
token RPAREN
	 numero entero
	 lista argumentos
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token STRING
token SEMI
	 cadena texto
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token LPAREN
token ID
token GT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion mayor
token OR
	 expresion parentesis
token LPAREN
token ID
token LT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion menor
token THEN
	 expresion parentesis
	 operacion OR
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token NOT
token LPAREN
token ID
token NE
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion diferente
token THEN
	 expresion parentesis
	 operacion NOT
token WRITE
token STRING
token END
	 cadena texto
	 write expresion
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
Array arr ocupa 10 posiciones de memoria
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 18
Variable: arr -> Direccion: 1
Variable: suma_vector -> Direccion: 11
Variable: total -> Direccion: 15
Variable: size -> Direccion: 13
Variable: resultado -> Direccion: 17
Variable: v -> Direccion: 12
Variable: num -> Direccion: 16
Variable: x -> Direccion: 0
Variable: i -> Direccion: 14


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LD        6,0(0)        load mp with maxaddr
1:      ST        0,0(0)        clear location 0
* * Fin del prefacio estandar
* -> programa
* -> declaracion: x
* Declaracion de variable: x (global)
2:      LDC       0,0(0)        global: inicializar variable x a cero
3:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: arr
* Declaracion de array: arr tamaño definido
* -> constante
4:      LDC       0,10(0)       cargar constante: 10
* <- constante
5:      LDC       0,0(0)        array: inicializar elemento 0 a cero
6:      ST        0,1(5)        array: almacenar en posicion 1
7:      LDC       0,0(0)        array: inicializar elemento 1 a cero
8:      ST        0,2(5)        array: almacenar en posicion 2
9:      LDC       0,0(0)        array: inicializar elemento 2 a cero
10:     ST        0,3(5)        array: almacenar en posicion 3
11:     LDC       0,0(0)        array: inicializar elemento 3 a cero
12:     ST        0,4(5)        array: almacenar en posicion 4
13:     LDC       0,0(0)        array: inicializar elemento 4 a cero
14:     ST        0,5(5)        array: almacenar en posicion 5
15:     LDC       0,0(0)        array: inicializar elemento 5 a cero
16:     ST        0,6(5)        array: almacenar en posicion 6
17:     LDC       0,0(0)        array: inicializar elemento 6 a cero
18:     ST        0,7(5)        array: almacenar en posicion 7
19:     LDC       0,0(0)        array: inicializar elemento 7 a cero
20:     ST        0,8(5)        array: almacenar en posicion 8
21:     LDC       0,0(0)        array: inicializar elemento 8 a cero
22:     ST        0,9(5)        array: almacenar en posicion 9
23:     LDC       0,0(0)        array: inicializar elemento 9 a cero
24:     ST        0,10(5)       array: almacenar en posicion 10
* <- declaracion
* registrada funcion: suma_vector
* -> declaracion: i
* Declaracion de variable: i (local)
25:     LDC       0,0(0)        local: inicializar variable i a cero
26:     ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> declaracion: num
* Declaracion de variable: num (local)
27:     LDC       0,0(0)        local: inicializar variable num a cero
28:     ST        0,16(5)       local: almacenar en direccion 16
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (local)
29:     LDC       0,0(0)        local: inicializar variable resultado a cero
30:     ST        0,17(5)       local: almacenar en direccion 17
* <- declaracion
* -> escribir
* -> string
* String: "Ingrese un número: "
31:     LDC       0,73(0)       string: cargar caracter 'I'
32:     OUT       0,0,0         string: escribir caracter
33:     LDC       0,110(0)      string: cargar caracter 'n'
34:     OUT       0,0,0         string: escribir caracter
35:     LDC       0,103(0)      string: cargar caracter 'g'
36:     OUT       0,0,0         string: escribir caracter
37:     LDC       0,114(0)      string: cargar caracter 'r'
38:     OUT       0,0,0         string: escribir caracter
39:     LDC       0,101(0)      string: cargar caracter 'e'
40:     OUT       0,0,0         string: escribir caracter
41:     LDC       0,115(0)      string: cargar caracter 's'
42:     OUT       0,0,0         string: escribir caracter
43:     LDC       0,101(0)      string: cargar caracter 'e'
44:     OUT       0,0,0         string: escribir caracter
45:     LDC       0,32(0)       string: cargar caracter ' '
46:     OUT       0,0,0         string: escribir caracter
47:     LDC       0,117(0)      string: cargar caracter 'u'
48:     OUT       0,0,0         string: escribir caracter
49:     LDC       0,110(0)      string: cargar caracter 'n'
50:     OUT       0,0,0         string: escribir caracter
51:     LDC       0,32(0)       string: cargar caracter ' '
52:     OUT       0,0,0         string: escribir caracter
53:     LDC       0,110(0)      string: cargar caracter 'n'
54:     OUT       0,0,0         string: escribir caracter
55:     LDC       0,250(0)      string: cargar caracter 'ú'
56:     OUT       0,0,0         string: escribir caracter
57:     LDC       0,109(0)      string: cargar caracter 'm'
58:     OUT       0,0,0         string: escribir caracter
59:     LDC       0,101(0)      string: cargar caracter 'e'
60:     OUT       0,0,0         string: escribir caracter
61:     LDC       0,114(0)      string: cargar caracter 'r'
62:     OUT       0,0,0         string: escribir caracter
63:     LDC       0,111(0)      string: cargar caracter 'o'
64:     OUT       0,0,0         string: escribir caracter
65:     LDC       0,58(0)       string: cargar caracter ':'
66:     OUT       0,0,0         string: escribir caracter
67:     LDC       0,32(0)       string: cargar caracter ' '
68:     OUT       0,0,0         string: escribir caracter
* <- string
69:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> leer
70:     IN        0,0,0         leer: lee un valor entero 
71:     ST        0,16(5)       leer: almaceno el valor entero leido en el id num
* <- leer
* -> for
* -> constante
72:     LDC       0,0(0)        cargar constante: 0
* <- constante
73:     ST        0,14(5)       for: inicializar variable i
* for: inicio del bucle
74:     LD        0,14(5)       for: cargar variable de control
75:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
76:     LDC       0,9(0)        cargar constante: 9
* <- constante
77:     LD        1,0(6)        for: cargar variable de pila temp
78:     SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> Operacion: por
* -> identificador
80:     LD        0,14(5)       cargar id: val[i]
* <- identificador
81:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
82:     LDC       0,2(0)        cargar constante: 2
* <- constante
83:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
84:     MUL       0,1,0         op: *
* <- Operacion: por
85:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
86:     LDC       0,1(0)        cargar constante: 1
* <- constante
87:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
88:     ADD       0,1,0         op: +
* <- Operacion: mas
89:     ST        0,0(6)        asignacion array: guardar valor
* -> identificador
90:     LD        0,14(5)       cargar id: val[i]
* <- identificador
91:     LDC       1,1(0)        asignacion array: cargar direccion base
92:     ADD       0,0,1         asignacion array: calcular direccion
93:     LD        1,0(6)        asignacion array: recuperar valor
94:     ST        1,0(0)        asignacion array: almacenar en posicion calculada
* <- asignacion
* for: punto de continue
95:     LD        0,14(5)       for: cargar variable para incremento
96:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
97:     LDC       0,1(0)        cargar constante: 1
* <- constante
98:     LD        1,0(6)        for: cargar variable de pila temp
99:     ADD       0,1,0         for: incrementar variable
100:    ST        0,14(5)       for: guardar variable incrementada
101:    LDA       7,-28(7)      for: salto al inicio
* for: fin del bucle
79:     JGT       0,22(7)       for: saltar si variable > final
* <- for
* -> if
* -> Operacion: and
* -> Operacion: mayorigual
* -> identificador
102:    LD        0,16(5)       cargar id: val[num]
* <- identificador
103:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
104:    LDC       0,0(0)        cargar constante: 0
* <- constante
105:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
106:    SUB       0,1,0         op: >=
107:    JGE       0,2(7)        saltar si AC>=0
108:    LDC       0,0(0)        caso falso
109:    LDA       7,1(7)        saltar caso verdadero
110:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
111:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menorigual
* -> identificador
112:    LD        0,16(5)       cargar id: val[num]
* <- identificador
113:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
114:    LDC       0,10(0)       cargar constante: 10
* <- constante
115:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
116:    SUB       0,1,0         op: <=
117:    JLE       0,2(7)        saltar si AC<=0
118:    LDC       0,0(0)        caso falso
119:    LDA       7,1(7)        saltar caso verdadero
120:    LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
121:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
122:    JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
123:    JEQ       0,2(7)        and: si derecho es falso, resultado es falso
124:    LDC       0,1(0)        and: ambos verdaderos
125:    LDA       7,1(7)        and: saltar caso falso
126:    LDC       0,0(0)        and: resultado falso
* <- Operacion: and
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "El número está en rango"
128:    LDC       0,69(0)       string: cargar caracter 'E'
129:    OUT       0,0,0         string: escribir caracter
130:    LDC       0,108(0)      string: cargar caracter 'l'
131:    OUT       0,0,0         string: escribir caracter
132:    LDC       0,32(0)       string: cargar caracter ' '
133:    OUT       0,0,0         string: escribir caracter
134:    LDC       0,110(0)      string: cargar caracter 'n'
135:    OUT       0,0,0         string: escribir caracter
136:    LDC       0,250(0)      string: cargar caracter 'ú'
137:    OUT       0,0,0         string: escribir caracter
138:    LDC       0,109(0)      string: cargar caracter 'm'
139:    OUT       0,0,0         string: escribir caracter
140:    LDC       0,101(0)      string: cargar caracter 'e'
141:    OUT       0,0,0         string: escribir caracter
142:    LDC       0,114(0)      string: cargar caracter 'r'
143:    OUT       0,0,0         string: escribir caracter
144:    LDC       0,111(0)      string: cargar caracter 'o'
145:    OUT       0,0,0         string: escribir caracter
146:    LDC       0,32(0)       string: cargar caracter ' '
147:    OUT       0,0,0         string: escribir caracter
148:    LDC       0,101(0)      string: cargar caracter 'e'
149:    OUT       0,0,0         string: escribir caracter
150:    LDC       0,115(0)      string: cargar caracter 's'
151:    OUT       0,0,0         string: escribir caracter
152:    LDC       0,116(0)      string: cargar caracter 't'
153:    OUT       0,0,0         string: escribir caracter
154:    LDC       0,225(0)      string: cargar caracter 'á'
155:    OUT       0,0,0         string: escribir caracter
156:    LDC       0,32(0)       string: cargar caracter ' '
157:    OUT       0,0,0         string: escribir caracter
158:    LDC       0,101(0)      string: cargar caracter 'e'
159:    OUT       0,0,0         string: escribir caracter
160:    LDC       0,110(0)      string: cargar caracter 'n'
161:    OUT       0,0,0         string: escribir caracter
162:    LDC       0,32(0)       string: cargar caracter ' '
163:    OUT       0,0,0         string: escribir caracter
164:    LDC       0,114(0)      string: cargar caracter 'r'
165:    OUT       0,0,0         string: escribir caracter
166:    LDC       0,97(0)       string: cargar caracter 'a'
167:    OUT       0,0,0         string: escribir caracter
168:    LDC       0,110(0)      string: cargar caracter 'n'
169:    OUT       0,0,0         string: escribir caracter
170:    LDC       0,103(0)      string: cargar caracter 'g'
171:    OUT       0,0,0         string: escribir caracter
172:    LDC       0,111(0)      string: cargar caracter 'o'
173:    OUT       0,0,0         string: escribir caracter
* <- string
174:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
175:    LD        0,16(5)       cargar id: val[num]
* <- identificador
176:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: igual
* -> Operacion: modulo
* -> identificador
177:    LD        0,16(5)       cargar id: val[num]
* <- identificador
178:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
179:    LDC       0,2(0)        cargar constante: 2
* <- constante
180:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
181:    ST        0,0(6)        mod: guardar b
182:    ST        1,-1(6)       mod: guardar a
183:    DIV       0,1,0         mod: a/b
184:    LD        1,-1(6)       mod: recuperar a
185:    LD        2,0(6)        mod: recuperar b en r2
186:    MUL       0,0,2         mod: (a/b)*b
187:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
188:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
189:    LDC       0,0(0)        cargar constante: 0
* <- constante
190:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
191:    SUB       0,1,0         op: ==
192:    JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
193:    LDC       0,0(0)        caso de falso (AC=0)
194:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
195:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "El número es par"
197:    LDC       0,69(0)       string: cargar caracter 'E'
198:    OUT       0,0,0         string: escribir caracter
199:    LDC       0,108(0)      string: cargar caracter 'l'
200:    OUT       0,0,0         string: escribir caracter
201:    LDC       0,32(0)       string: cargar caracter ' '
202:    OUT       0,0,0         string: escribir caracter
203:    LDC       0,110(0)      string: cargar caracter 'n'
204:    OUT       0,0,0         string: escribir caracter
205:    LDC       0,250(0)      string: cargar caracter 'ú'
206:    OUT       0,0,0         string: escribir caracter
207:    LDC       0,109(0)      string: cargar caracter 'm'
208:    OUT       0,0,0         string: escribir caracter
209:    LDC       0,101(0)      string: cargar caracter 'e'
210:    OUT       0,0,0         string: escribir caracter
211:    LDC       0,114(0)      string: cargar caracter 'r'
212:    OUT       0,0,0         string: escribir caracter
213:    LDC       0,111(0)      string: cargar caracter 'o'
214:    OUT       0,0,0         string: escribir caracter
215:    LDC       0,32(0)       string: cargar caracter ' '
216:    OUT       0,0,0         string: escribir caracter
217:    LDC       0,101(0)      string: cargar caracter 'e'
218:    OUT       0,0,0         string: escribir caracter
219:    LDC       0,115(0)      string: cargar caracter 's'
220:    OUT       0,0,0         string: escribir caracter
221:    LDC       0,32(0)       string: cargar caracter ' '
222:    OUT       0,0,0         string: escribir caracter
223:    LDC       0,112(0)      string: cargar caracter 'p'
224:    OUT       0,0,0         string: escribir caracter
225:    LDC       0,97(0)       string: cargar caracter 'a'
226:    OUT       0,0,0         string: escribir caracter
227:    LDC       0,114(0)      string: cargar caracter 'r'
228:    OUT       0,0,0         string: escribir caracter
* <- string
229:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
196:    JEQ       0,34(7)       if: jmp hacia else
* -> escribir
* -> string
* String: "El número es impar"
231:    LDC       0,69(0)       string: cargar caracter 'E'
232:    OUT       0,0,0         string: escribir caracter
233:    LDC       0,108(0)      string: cargar caracter 'l'
234:    OUT       0,0,0         string: escribir caracter
235:    LDC       0,32(0)       string: cargar caracter ' '
236:    OUT       0,0,0         string: escribir caracter
237:    LDC       0,110(0)      string: cargar caracter 'n'
238:    OUT       0,0,0         string: escribir caracter
239:    LDC       0,250(0)      string: cargar caracter 'ú'
240:    OUT       0,0,0         string: escribir caracter
241:    LDC       0,109(0)      string: cargar caracter 'm'
242:    OUT       0,0,0         string: escribir caracter
243:    LDC       0,101(0)      string: cargar caracter 'e'
244:    OUT       0,0,0         string: escribir caracter
245:    LDC       0,114(0)      string: cargar caracter 'r'
246:    OUT       0,0,0         string: escribir caracter
247:    LDC       0,111(0)      string: cargar caracter 'o'
248:    OUT       0,0,0         string: escribir caracter
249:    LDC       0,32(0)       string: cargar caracter ' '
250:    OUT       0,0,0         string: escribir caracter
251:    LDC       0,101(0)      string: cargar caracter 'e'
252:    OUT       0,0,0         string: escribir caracter
253:    LDC       0,115(0)      string: cargar caracter 's'
254:    OUT       0,0,0         string: escribir caracter
255:    LDC       0,32(0)       string: cargar caracter ' '
256:    OUT       0,0,0         string: escribir caracter
257:    LDC       0,105(0)      string: cargar caracter 'i'
258:    OUT       0,0,0         string: escribir caracter
259:    LDC       0,109(0)      string: cargar caracter 'm'
260:    OUT       0,0,0         string: escribir caracter
261:    LDC       0,112(0)      string: cargar caracter 'p'
262:    OUT       0,0,0         string: escribir caracter
263:    LDC       0,97(0)       string: cargar caracter 'a'
264:    OUT       0,0,0         string: escribir caracter
265:    LDC       0,114(0)      string: cargar caracter 'r'
266:    OUT       0,0,0         string: escribir caracter
* <- string
267:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
230:    LDA       7,37(7)       if: jmp hacia el final
* <- if
* -> asignacion
* -> Operacion: potencia
* -> identificador
268:    LD        0,16(5)       cargar id: val[num]
* <- identificador
269:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
270:    LDC       0,2(0)        cargar constante: 2
* <- constante
271:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
272:    ST        0,0(6)        pow: guardar exp
273:    ST        1,-1(6)       pow: guardar base
274:    LDC       0,1(0)        pow: inicializar resultado = 1
275:    ST        0,-2(6)       pow: guardar res
* pow: inicio bucle
276:    LD        0,0(6)        pow: cargar exp
* pow: salto condicional a fin (exp==0)
278:    LD        0,-2(6)       pow: cargar res
279:    LD        1,-1(6)       pow: cargar base
280:    MUL       0,1,0         pow: res = res * base
281:    ST        0,-2(6)       pow: guardar res
282:    LD        1,0(6)        pow: cargar exp en AC1
283:    LDC       0,1(0)        pow: cargar 1
284:    SUB       0,1,0         pow: exp - 1
285:    ST        0,0(6)        pow: guardar exp
286:    LDA       7,-11(7)      pow: repetir
277:    JEQ       0,9(7)        pow: salir si exp == 0
287:    LD        0,-2(6)       pow: cargar resultado
288:    LD        1,-2(6)       pow: pop res
289:    LD        1,-1(6)       pow: pop base
290:    LD        1,0(6)        pow: pop exp
* <- Operacion: potencia
291:    ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> escribir
* -> string
* String: "El cuadrado es: "
292:    LDC       0,69(0)       string: cargar caracter 'E'
293:    OUT       0,0,0         string: escribir caracter
294:    LDC       0,108(0)      string: cargar caracter 'l'
295:    OUT       0,0,0         string: escribir caracter
296:    LDC       0,32(0)       string: cargar caracter ' '
297:    OUT       0,0,0         string: escribir caracter
298:    LDC       0,99(0)       string: cargar caracter 'c'
299:    OUT       0,0,0         string: escribir caracter
300:    LDC       0,117(0)      string: cargar caracter 'u'
301:    OUT       0,0,0         string: escribir caracter
302:    LDC       0,97(0)       string: cargar caracter 'a'
303:    OUT       0,0,0         string: escribir caracter
304:    LDC       0,100(0)      string: cargar caracter 'd'
305:    OUT       0,0,0         string: escribir caracter
306:    LDC       0,114(0)      string: cargar caracter 'r'
307:    OUT       0,0,0         string: escribir caracter
308:    LDC       0,97(0)       string: cargar caracter 'a'
309:    OUT       0,0,0         string: escribir caracter
310:    LDC       0,100(0)      string: cargar caracter 'd'
311:    OUT       0,0,0         string: escribir caracter
312:    LDC       0,111(0)      string: cargar caracter 'o'
313:    OUT       0,0,0         string: escribir caracter
314:    LDC       0,32(0)       string: cargar caracter ' '
315:    OUT       0,0,0         string: escribir caracter
316:    LDC       0,101(0)      string: cargar caracter 'e'
317:    OUT       0,0,0         string: escribir caracter
318:    LDC       0,115(0)      string: cargar caracter 's'
319:    OUT       0,0,0         string: escribir caracter
320:    LDC       0,58(0)       string: cargar caracter ':'
321:    OUT       0,0,0         string: escribir caracter
322:    LDC       0,32(0)       string: cargar caracter ' '
323:    OUT       0,0,0         string: escribir caracter
* <- string
324:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
325:    LD        0,0(5)        cargar id: val[x]
* <- identificador
326:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
127:    JEQ       0,200(7)      if: jmp hacia else
* -> escribir
* -> string
* String: "Número fuera de rango"
328:    LDC       0,78(0)       string: cargar caracter 'N'
329:    OUT       0,0,0         string: escribir caracter
330:    LDC       0,250(0)      string: cargar caracter 'ú'
331:    OUT       0,0,0         string: escribir caracter
332:    LDC       0,109(0)      string: cargar caracter 'm'
333:    OUT       0,0,0         string: escribir caracter
334:    LDC       0,101(0)      string: cargar caracter 'e'
335:    OUT       0,0,0         string: escribir caracter
336:    LDC       0,114(0)      string: cargar caracter 'r'
337:    OUT       0,0,0         string: escribir caracter
338:    LDC       0,111(0)      string: cargar caracter 'o'
339:    OUT       0,0,0         string: escribir caracter
340:    LDC       0,32(0)       string: cargar caracter ' '
341:    OUT       0,0,0         string: escribir caracter
342:    LDC       0,102(0)      string: cargar caracter 'f'
343:    OUT       0,0,0         string: escribir caracter
344:    LDC       0,117(0)      string: cargar caracter 'u'
345:    OUT       0,0,0         string: escribir caracter
346:    LDC       0,101(0)      string: cargar caracter 'e'
347:    OUT       0,0,0         string: escribir caracter
348:    LDC       0,114(0)      string: cargar caracter 'r'
349:    OUT       0,0,0         string: escribir caracter
350:    LDC       0,97(0)       string: cargar caracter 'a'
351:    OUT       0,0,0         string: escribir caracter
352:    LDC       0,32(0)       string: cargar caracter ' '
353:    OUT       0,0,0         string: escribir caracter
354:    LDC       0,100(0)      string: cargar caracter 'd'
355:    OUT       0,0,0         string: escribir caracter
356:    LDC       0,101(0)      string: cargar caracter 'e'
357:    OUT       0,0,0         string: escribir caracter
358:    LDC       0,32(0)       string: cargar caracter ' '
359:    OUT       0,0,0         string: escribir caracter
360:    LDC       0,114(0)      string: cargar caracter 'r'
361:    OUT       0,0,0         string: escribir caracter
362:    LDC       0,97(0)       string: cargar caracter 'a'
363:    OUT       0,0,0         string: escribir caracter
364:    LDC       0,110(0)      string: cargar caracter 'n'
365:    OUT       0,0,0         string: escribir caracter
366:    LDC       0,103(0)      string: cargar caracter 'g'
367:    OUT       0,0,0         string: escribir caracter
368:    LDC       0,111(0)      string: cargar caracter 'o'
369:    OUT       0,0,0         string: escribir caracter
* <- string
370:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
327:    LDA       7,43(7)       if: jmp hacia el final
* <- if
* -> asignacion
* -> llamada funcion: suma_vector
371:    ST        7,0(6)        call: guardar direccion de retorno
* Procesando argumentos de la llamada
* -> identificador
372:    LD        0,1(5)        cargar id: val[arr]
* <- identificador
* -> constante
373:    LDC       0,10(0)       cargar constante: 10
* <- constante
374:    ST        0,-1(6)       call: guardar argumento
* -> constante
375:    LDC       0,10(0)       cargar constante: 10
* <- constante
376:    ST        0,-2(6)       call: guardar argumento
* === INICIO FUNCION suma_vector ===
* -> declaracion: i
* Declaracion de variable: i (local)
377:    LDC       0,0(0)        local: inicializar variable i a cero
378:    ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> declaracion: total
* Declaracion de variable: total (local)
379:    LDC       0,0(0)        local: inicializar variable total a cero
380:    ST        0,15(5)       local: almacenar en direccion 15
* <- declaracion
* -> asignacion
* -> constante
381:    LDC       0,0(0)        cargar constante: 0
* <- constante
382:    ST        0,15(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> for
* -> constante
383:    LDC       0,0(0)        cargar constante: 0
* <- constante
384:    ST        0,14(5)       for: inicializar variable i
* for: inicio del bucle
385:    LD        0,14(5)       for: cargar variable de control
386:    ST        0,-3(6)       for: guardar variable en pila temp
* -> Operacion: menos
* -> identificador
387:    LD        0,13(5)       cargar id: val[size]
* <- identificador
388:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
389:    LDC       0,1(0)        cargar constante: 1
* <- constante
390:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
391:    SUB       0,1,0         op: -
* <- Operacion: menos
392:    LD        1,-3(6)       for: cargar variable de pila temp
393:    SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> identificador
395:    LD        0,15(5)       cargar id: val[total]
* <- identificador
396:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> identificador
397:    LD        0,14(5)       cargar id: val[i]
* <- identificador
398:    LDC       1,12(0)       identificador array: cargar direccion base
399:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
400:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
401:    ADD       0,1,0         op: +
* <- Operacion: mas
402:    ST        0,15(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> if
* -> Operacion: menor
* -> identificador
* -> identificador
403:    LD        0,14(5)       cargar id: val[i]
* <- identificador
404:    LDC       1,12(0)       identificador array: cargar direccion base
405:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
406:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
407:    LDC       0,0(0)        cargar constante: 0
* <- constante
408:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
409:    SUB       0,1,0         op: <
410:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
411:    LDC       0,0(0)        caso de falso (AC=0)
412:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
413:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
* If: el salto hacia el else debe estar aqui
* -> continue
* continue: salto al incremento del bucle
* <- continue
* If: el salto hacia el final debe estar aqui
414:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: mayor
* -> identificador
416:    LD        0,15(5)       cargar id: val[total]
* <- identificador
417:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
418:    LDC       0,1000(0)      cargar constante: 1000
* <- constante
419:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
420:    SUB       0,1,0         op: >
421:    JGT       0,2(7)        saltar si AC>0
422:    LDC       0,0(0)        caso falso
423:    LDA       7,1(7)        saltar caso verdadero
424:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
* If: el salto hacia el else debe estar aqui
* -> break
* break: salto al final del bucle
* <- break
* If: el salto hacia el final debe estar aqui
425:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* for: punto de continue
427:    LD        0,14(5)       for: cargar variable para incremento
428:    ST        0,-3(6)       for: guardar variable en pila temp
* -> constante
429:    LDC       0,1(0)        cargar constante: 1
* <- constante
430:    LD        1,-3(6)       for: cargar variable de pila temp
431:    ADD       0,1,0         for: incrementar variable
432:    ST        0,14(5)       for: guardar variable incrementada
433:    LDA       7,-49(7)      for: salto al inicio
* for: fin del bucle
394:    JGT       0,39(7)       for: saltar si variable > final
* <- for
* -> return
* -> identificador
434:    LD        0,15(5)       cargar id: val[total]
* <- identificador
435:    LD        1,-2(6)       return: recuperar direccion de retorno
436:    LD        7,0(1)        return: salto a direccion de retorno
* <- return
* Return implicito de funcion
437:    LD        1,-1(6)       funcion: recuperar direccion de retorno
438:    LD        7,0(1)        funcion: retorno
* === FIN FUNCION suma_vector ===
377:    LDA       7,-1(7)       call: salto a funcion suma_vector
* <- llamada funcion
439:    ST        0,17(5)       asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> string
* String: "La suma del vector es: "
440:    LDC       0,76(0)       string: cargar caracter 'L'
441:    OUT       0,0,0         string: escribir caracter
442:    LDC       0,97(0)       string: cargar caracter 'a'
443:    OUT       0,0,0         string: escribir caracter
444:    LDC       0,32(0)       string: cargar caracter ' '
445:    OUT       0,0,0         string: escribir caracter
446:    LDC       0,115(0)      string: cargar caracter 's'
447:    OUT       0,0,0         string: escribir caracter
448:    LDC       0,117(0)      string: cargar caracter 'u'
449:    OUT       0,0,0         string: escribir caracter
450:    LDC       0,109(0)      string: cargar caracter 'm'
451:    OUT       0,0,0         string: escribir caracter
452:    LDC       0,97(0)       string: cargar caracter 'a'
453:    OUT       0,0,0         string: escribir caracter
454:    LDC       0,32(0)       string: cargar caracter ' '
455:    OUT       0,0,0         string: escribir caracter
456:    LDC       0,100(0)      string: cargar caracter 'd'
457:    OUT       0,0,0         string: escribir caracter
458:    LDC       0,101(0)      string: cargar caracter 'e'
459:    OUT       0,0,0         string: escribir caracter
460:    LDC       0,108(0)      string: cargar caracter 'l'
461:    OUT       0,0,0         string: escribir caracter
462:    LDC       0,32(0)       string: cargar caracter ' '
463:    OUT       0,0,0         string: escribir caracter
464:    LDC       0,118(0)      string: cargar caracter 'v'
465:    OUT       0,0,0         string: escribir caracter
466:    LDC       0,101(0)      string: cargar caracter 'e'
467:    OUT       0,0,0         string: escribir caracter
468:    LDC       0,99(0)       string: cargar caracter 'c'
469:    OUT       0,0,0         string: escribir caracter
470:    LDC       0,116(0)      string: cargar caracter 't'
471:    OUT       0,0,0         string: escribir caracter
472:    LDC       0,111(0)      string: cargar caracter 'o'
473:    OUT       0,0,0         string: escribir caracter
474:    LDC       0,114(0)      string: cargar caracter 'r'
475:    OUT       0,0,0         string: escribir caracter
476:    LDC       0,32(0)       string: cargar caracter ' '
477:    OUT       0,0,0         string: escribir caracter
478:    LDC       0,101(0)      string: cargar caracter 'e'
479:    OUT       0,0,0         string: escribir caracter
480:    LDC       0,115(0)      string: cargar caracter 's'
481:    OUT       0,0,0         string: escribir caracter
482:    LDC       0,58(0)       string: cargar caracter ':'
483:    OUT       0,0,0         string: escribir caracter
484:    LDC       0,32(0)       string: cargar caracter ' '
485:    OUT       0,0,0         string: escribir caracter
* <- string
486:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
487:    LD        0,17(5)       cargar id: val[resultado]
* <- identificador
488:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: or
* -> Operacion: mayor
* -> identificador
489:    LD        0,16(5)       cargar id: val[num]
* <- identificador
490:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
491:    LDC       0,5(0)        cargar constante: 5
* <- constante
492:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
493:    SUB       0,1,0         op: >
494:    JGT       0,2(7)        saltar si AC>0
495:    LDC       0,0(0)        caso falso
496:    LDA       7,1(7)        saltar caso verdadero
497:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
498:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menor
* -> identificador
499:    LD        0,16(5)       cargar id: val[num]
* <- identificador
500:    ST        0,-2(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
501:    LDC       0,0(0)        cargar constante: 0
* <- constante
502:    LD        1,-2(6)       op: pop o cargo de la pila el valor izquierdo en AC1
503:    SUB       0,1,0         op: <
504:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
505:    LDC       0,0(0)        caso de falso (AC=0)
506:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
507:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
508:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
509:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
510:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
511:    LDC       0,0(0)        or: ambos falsos
512:    LDA       7,1(7)        or: saltar caso verdadero
513:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "Condición compleja verdadera"
515:    LDC       0,67(0)       string: cargar caracter 'C'
516:    OUT       0,0,0         string: escribir caracter
517:    LDC       0,111(0)      string: cargar caracter 'o'
518:    OUT       0,0,0         string: escribir caracter
519:    LDC       0,110(0)      string: cargar caracter 'n'
520:    OUT       0,0,0         string: escribir caracter
521:    LDC       0,100(0)      string: cargar caracter 'd'
522:    OUT       0,0,0         string: escribir caracter
523:    LDC       0,105(0)      string: cargar caracter 'i'
524:    OUT       0,0,0         string: escribir caracter
525:    LDC       0,99(0)       string: cargar caracter 'c'
526:    OUT       0,0,0         string: escribir caracter
527:    LDC       0,105(0)      string: cargar caracter 'i'
528:    OUT       0,0,0         string: escribir caracter
529:    LDC       0,243(0)      string: cargar caracter 'ó'
530:    OUT       0,0,0         string: escribir caracter
531:    LDC       0,110(0)      string: cargar caracter 'n'
532:    OUT       0,0,0         string: escribir caracter
533:    LDC       0,32(0)       string: cargar caracter ' '
534:    OUT       0,0,0         string: escribir caracter
535:    LDC       0,99(0)       string: cargar caracter 'c'
536:    OUT       0,0,0         string: escribir caracter
537:    LDC       0,111(0)      string: cargar caracter 'o'
538:    OUT       0,0,0         string: escribir caracter
539:    LDC       0,109(0)      string: cargar caracter 'm'
540:    OUT       0,0,0         string: escribir caracter
541:    LDC       0,112(0)      string: cargar caracter 'p'
542:    OUT       0,0,0         string: escribir caracter
543:    LDC       0,108(0)      string: cargar caracter 'l'
544:    OUT       0,0,0         string: escribir caracter
545:    LDC       0,101(0)      string: cargar caracter 'e'
546:    OUT       0,0,0         string: escribir caracter
547:    LDC       0,106(0)      string: cargar caracter 'j'
548:    OUT       0,0,0         string: escribir caracter
549:    LDC       0,97(0)       string: cargar caracter 'a'
550:    OUT       0,0,0         string: escribir caracter
551:    LDC       0,32(0)       string: cargar caracter ' '
552:    OUT       0,0,0         string: escribir caracter
553:    LDC       0,118(0)      string: cargar caracter 'v'
554:    OUT       0,0,0         string: escribir caracter
555:    LDC       0,101(0)      string: cargar caracter 'e'
556:    OUT       0,0,0         string: escribir caracter
557:    LDC       0,114(0)      string: cargar caracter 'r'
558:    OUT       0,0,0         string: escribir caracter
559:    LDC       0,100(0)      string: cargar caracter 'd'
560:    OUT       0,0,0         string: escribir caracter
561:    LDC       0,97(0)       string: cargar caracter 'a'
562:    OUT       0,0,0         string: escribir caracter
563:    LDC       0,100(0)      string: cargar caracter 'd'
564:    OUT       0,0,0         string: escribir caracter
565:    LDC       0,101(0)      string: cargar caracter 'e'
566:    OUT       0,0,0         string: escribir caracter
567:    LDC       0,114(0)      string: cargar caracter 'r'
568:    OUT       0,0,0         string: escribir caracter
569:    LDC       0,97(0)       string: cargar caracter 'a'
570:    OUT       0,0,0         string: escribir caracter
* <- string
571:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
514:    JEQ       0,58(7)       if: jmp hacia else
* <- if
* -> if
* -> Operacion: not
* -> Operacion: diferente
* -> identificador
573:    LD        0,16(5)       cargar id: val[num]
* <- identificador
574:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
575:    LDC       0,5(0)        cargar constante: 5
* <- constante
576:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
577:    SUB       0,1,0         op: !=
578:    JNE       0,2(7)        saltar si AC!=0
579:    LDC       0,0(0)        caso falso
580:    LDA       7,1(7)        saltar caso verdadero
581:    LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
582:    JEQ       0,2(7)        not: saltar si es cero (falso)
583:    LDC       0,0(0)        not: resultado falso
584:    LDA       7,1(7)        not: saltar carga de verdadero
585:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> string
* String: "El número es 5"
587:    LDC       0,69(0)       string: cargar caracter 'E'
588:    OUT       0,0,0         string: escribir caracter
589:    LDC       0,108(0)      string: cargar caracter 'l'
590:    OUT       0,0,0         string: escribir caracter
591:    LDC       0,32(0)       string: cargar caracter ' '
592:    OUT       0,0,0         string: escribir caracter
593:    LDC       0,110(0)      string: cargar caracter 'n'
594:    OUT       0,0,0         string: escribir caracter
595:    LDC       0,250(0)      string: cargar caracter 'ú'
596:    OUT       0,0,0         string: escribir caracter
597:    LDC       0,109(0)      string: cargar caracter 'm'
598:    OUT       0,0,0         string: escribir caracter
599:    LDC       0,101(0)      string: cargar caracter 'e'
600:    OUT       0,0,0         string: escribir caracter
601:    LDC       0,114(0)      string: cargar caracter 'r'
602:    OUT       0,0,0         string: escribir caracter
603:    LDC       0,111(0)      string: cargar caracter 'o'
604:    OUT       0,0,0         string: escribir caracter
605:    LDC       0,32(0)       string: cargar caracter ' '
606:    OUT       0,0,0         string: escribir caracter
607:    LDC       0,101(0)      string: cargar caracter 'e'
608:    OUT       0,0,0         string: escribir caracter
609:    LDC       0,115(0)      string: cargar caracter 's'
610:    OUT       0,0,0         string: escribir caracter
611:    LDC       0,32(0)       string: cargar caracter ' '
612:    OUT       0,0,0         string: escribir caracter
613:    LDC       0,53(0)       string: cargar caracter '5'
614:    OUT       0,0,0         string: escribir caracter
* <- string
615:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
586:    JEQ       0,30(7)       if: jmp hacia else
* <- if
* <- programa
* Fin de la ejecucion.
617:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------
